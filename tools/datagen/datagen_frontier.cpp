/*
 * datagen-frontier
 *
 * Usage: datagen-frontier <OUT_DIR> <TRAINER_DATA_DIR> <POKEMON_DATA_DIR>
 *
 * The following files are generated by this program:
 *   - pl_btdtr.narc
 *   - pl_btdpm.narc
 */

#include <cstdlib>
#include <cstring>
#include <exception>
#include <map>

#include "datagen.h"

#define POKEPLATINUM_GENERATED_ENUM
#define POKEPLATINUM_GENERATED_LOOKUP
#define POKEPLATINUM_GENERATED_LOOKUP_IMPL

#include "generated/items.h"
#include "generated/moves.h"
#include "generated/natures.h"
#include "generated/species.h"
#include "generated/trainer_classes.h"

#include "struct_defs/battle_frontier_pokemon_data.h"

std::map<std::string, int, std::less<>> MapSetnameToId;

static void BuildFrontierMonLookupTable(const std::vector<std::string> pokemonRegistry)
{
    for (int index = 0; index < pokemonRegistry.size(); index++) {
        MapSetnameToId[pokemonRegistry[index]] = index;
    }
}

static void ParseSetIDs(const rapidjson::Value &member, u16 *trdata)
{
    int i, numSets = 0;
    for (const auto &value : member.GetArray()) {
        trdata[2 + i++] = MapSetnameToId[value.GetString()];

        if (value != "none_1") {
            numSets++;
        }
    }
    trdata[1] = numSets;
}

static void PackFrontierTrainer(const rapidjson::Document &doc, vfs_pack_ctx *pl_btdtrVFS)
{
    int dataSize = 2 + doc["availableSets"].GetArray().Size();
    u16 trdata[dataSize] = { 0 };

    trdata[0] = LookupConst(doc["class"].GetString(), TrainerClass);

    ParseSetIDs(doc["availableSets"], trdata);

    narc_pack_file_copy(pl_btdtrVFS, reinterpret_cast<unsigned char *>(&trdata), sizeof(trdata));
}

static void ParseMoves(const rapidjson::Value &moves, BattleFrontierPokemonData &data)
{
    for (int i = 0; i < LEARNED_MOVES_MAX; i++) {
        data.moves[i] = LookupConst(moves.GetArray()[i].GetString(), Move);
    }
}

static void ParseEvFlags(const rapidjson::Value &evFlags, BattleFrontierPokemonData &data)
{
    data.evFlags = 0;
    if (evFlags["hp"].GetBool()) {
        data.evFlags += 1 << 0;
    }
    if (evFlags["attack"].GetBool()) {
        data.evFlags += 1 << 1;
    }
    if (evFlags["defense"].GetBool()) {
        data.evFlags += 1 << 2;
    }
    if (evFlags["speed"].GetBool()) {
        data.evFlags += 1 << 3;
    }
    if (evFlags["special_attack"].GetBool()) {
        data.evFlags += 1 << 4;
    }
    if (evFlags["special_defense"].GetBool()) {
        data.evFlags += 1 << 5;
    }
}

static BattleFrontierPokemonData ParseFrontierPokemon(const rapidjson::Document &doc)
{
    BattleFrontierPokemonData data = {};
    data.species = LookupConst(doc["species"].GetString(), Species);
    ParseMoves(doc["moves"], data);
    ParseEvFlags(doc["evFlags"], data);
    data.nature = LookupConst(doc["nature"].GetString(), Nature);
    data.item = LookupConst(doc["item"].GetString(), Item);
    data.form = doc["form"].GetUint();

    return data;
}

static void LoadJson(rapidjson::Document &doc, fs::path filePath)
{
    std::string json = ReadWholeFile(filePath);
    rapidjson::ParseResult ok = doc.Parse(json.c_str(), json.length());
    if (!ok) {
        ReportJsonError(ok, json, filePath);
        std::exit(EXIT_FAILURE);
    }
}

int main(int argc, char **argv)
{
    if (argc == 1) {
        return EXIT_SUCCESS;
    }

    fs::path outputRoot = argv[1];
    fs::path trainerDataRoot = argv[2];
    fs::path pokemonDataRoot = argv[3];

    std::vector<std::string> trainerRegistry = ReadRegistryEnvVar("TRAINERS");
    std::vector<std::string> pokemonRegistry = ReadRegistryEnvVar("POKEMONS");

    BuildFrontierMonLookupTable(pokemonRegistry);

    vfs_pack_ctx *pl_btdtrVFS = narc_pack_start();
    vfs_pack_ctx *pl_btdpmVFS = narc_pack_start();

    rapidjson::Document doc;
    for (auto &trainerStem : trainerRegistry) {
        fs::path trainerDataPath = trainerDataRoot / (trainerStem + ".json");
        LoadJson(doc, trainerDataPath);

        try {
            PackFrontierTrainer(doc, pl_btdtrVFS);
        } catch (const std::exception &e) {
            std::cerr << e.what() << std::endl;
            std::exit(EXIT_FAILURE);
        }
    }

    for (auto &pokemonStem : pokemonRegistry) {
        fs::path pokemonDataPath = pokemonDataRoot / (pokemonStem + ".json");
        LoadJson(doc, pokemonDataPath);

        try {
            BattleFrontierPokemonData pmdata = ParseFrontierPokemon(doc);

            narc_pack_file_copy(pl_btdpmVFS, reinterpret_cast<unsigned char *>(&pmdata), sizeof(pmdata));
        } catch (const std::exception &e) {
            std::cerr << e.what() << std::endl;
            std::exit(EXIT_FAILURE);
        }
    }

    PackNarc(pl_btdtrVFS, outputRoot / "pl_btdtr.narc");
    PackNarc(pl_btdpmVFS, outputRoot / "pl_btdpm.narc");
    return EXIT_SUCCESS;
}
