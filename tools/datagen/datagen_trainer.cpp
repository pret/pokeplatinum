/*
 * datagen-trainer
 *
 * Usage: datagen-species <OUT_DIR> <ROOT_DIR>
 *
 * This program is responsible for generating data archives from trainer data
 * files (res/trainers/data/*.json). The file-names to be polled for data are
 * drawn from an environment var TRAINERS, which should be a semicolon-delimited
 * list of file-stems.
 *
 * The following files are generated by this program:
 *   - trdata.narc
 *   - trpoke.narc
 */
#include <cstdlib>
#include <cstring>
#include <exception>
#include <functional>

#include "datagen_trainer.h"
#include "datagen.h"

#define POKEPLATINUM_GENERATED_LOOKUP
#define POKEPLATINUM_GENERATED_LOOKUP_IMPL

// C++ does not like the math expressions used in this enum,
// so use the preprocessor version instead.
#include "generated/ai_flags.h"

#define POKEPLATINUM_GENERATED_ENUM

#include "constants/battle.h"
#include "generated/items.h"
#include "generated/moves.h"
#include "generated/species.h"
#include "generated/trainer_classes.h"
#include "generated/trainer_message_types.h"

#include "struct_defs/trainer_data.h"

static void PackImmediately(const rapidjson::Value &member, TrainerMonBase &base, unsigned char *bufp);
static void ParseMovesAndPack(const rapidjson::Value &member, TrainerMonBase &base, unsigned char *bufp);
static void ParseItemAndPack(const rapidjson::Value &member, TrainerMonBase &base, unsigned char *bufp);
static void ParseMovesAndItemAndPack(const rapidjson::Value &member, TrainerMonBase &base, unsigned char *bufp);

typedef std::function<void(const rapidjson::Value &member, TrainerMonBase &base, unsigned char *bufp)> TrainerMonSubparser;

struct TrainerDataTypeTable {
    TrainerMonSubparser subparser;
    std::size_t monSize;
};

static TrainerDataTypeTable sTrainerDataTypeTable[] = {
    { PackImmediately, sizeof(TrainerMonBase) },
    { ParseMovesAndPack, sizeof(TrainerMonWithMoves) },
    { ParseItemAndPack, sizeof(TrainerMonWithItem) },
    { ParseMovesAndItemAndPack, sizeof(TrainerMonWithMovesAndItem) },
};

static void Usage(std::ostream &ostr)
{
    ostr << "Usage: datagen-species OUT_DIR ROOT_DIR" << std::endl;
    ostr << std::endl;
    ostr << "Generates data archives from trainer data files (res/trainers/data/*.json)" << std::endl;
    ostr << "Trainer data files to be polled for packing are drawn from the environment var\n"
         << "TRAINERS, which must be a semicolon-delimited list of file-stems to be polled\n"
         << "at execution." << std::endl;
}

static inline bool AnyMemberHasValue(const rapidjson::Value &party, const char *key)
{
    for (const auto &member : party.GetArray()) {
        if (!member[key].IsNull()) {
            return true;
        }
    }

    return false;
}

static TrainerHeader ParseTrainerData(const rapidjson::Document &doc)
{
    TrainerHeader trdata = {};

    trdata.trainerType = LookupConst(doc["class"].GetString(), TrainerClass);
    trdata.battleType = doc["double_battle"].GetBool() ? BATTLE_TYPE_DOUBLES : 0;

    int i = 0;
    for (const auto &itemVal : doc["items"].GetArray()) {
        trdata.items[i++] = LookupConst(itemVal.GetString(), Item);
    }

    for (const auto &aiFlagsVal : doc["ai_flags"].GetArray()) {
        trdata.aiMask |= LookupConst(aiFlagsVal.GetString(), AIFlag);
    }

    const rapidjson::Value &party = doc["party"];
    trdata.partySize = party.GetArray().Size();

    bool partyItems = AnyMemberHasValue(party, "item");
    bool partyMoves = AnyMemberHasValue(party, "moves");
    if (partyItems) {
        if (partyMoves) {
            trdata.monDataType = TRDATATYPE_WITH_MOVES_AND_ITEM;
        } else {
            trdata.monDataType = TRDATATYPE_WITH_ITEM;
        }
    } else if (partyMoves) {
        trdata.monDataType = TRDATATYPE_WITH_MOVES;
    } else {
        trdata.monDataType = TRDATATYPE_BASE;
    }

    return trdata;
}

static void PackImmediately(const rapidjson::Value &member, TrainerMonBase &base, unsigned char *bufp)
{
    memcpy(bufp, &base, sizeof(base));
}

static void ParseMovesAndPack(const rapidjson::Value &member, TrainerMonBase &base, unsigned char *bufp)
{
    TrainerMonWithMoves withMoves = {};
    withMoves.dv = base.dv;
    withMoves.level = base.level;
    withMoves.species = base.species;
    withMoves.cbSeal = base.cbSeal;

    int i = 0;
    for (const auto &move : member["moves"].GetArray()) {
        withMoves.moves[i++] = LookupConst(move.GetString(), Move);
    }

    memcpy(bufp, &withMoves, sizeof(withMoves));
}

static void ParseItemAndPack(const rapidjson::Value &member, TrainerMonBase &base, unsigned char *bufp)
{
    TrainerMonWithItem withItem = {};
    withItem.dv = base.dv;
    withItem.level = base.level;
    withItem.species = base.species;
    withItem.cbSeal = base.cbSeal;

    withItem.item = LookupConst(member["item"].GetString(), Item);

    memcpy(bufp, &withItem, sizeof(withItem));
}

static void ParseMovesAndItemAndPack(const rapidjson::Value &member, TrainerMonBase &base, unsigned char *bufp)
{
    TrainerMonWithMovesAndItem withMovesAndItem = {};
    withMovesAndItem.dv = base.dv;
    withMovesAndItem.level = base.level;
    withMovesAndItem.species = base.species;
    withMovesAndItem.cbSeal = base.cbSeal;

    int i = 0;
    for (const auto &move : member["moves"].GetArray()) {
        withMovesAndItem.moves[i++] = LookupConst(move.GetString(), Move);
    }

    withMovesAndItem.item = LookupConst(member["item"].GetString(), Item);

    memcpy(bufp, &withMovesAndItem, sizeof(withMovesAndItem));
}

static void ParseAndPackParty(const rapidjson::Document &doc, TrainerDataType monDataType, std::size_t partySize, vfs_pack_ctx *trpokeVFS)
{
    if (partySize == 0) {
        unsigned char *buf = (unsigned char *)calloc(8, 1);
        narc_pack_file(trpokeVFS, buf, 8);
        return;
    }

    TrainerMonSubparser subparser = sTrainerDataTypeTable[monDataType].subparser;
    std::size_t monSize = sTrainerDataTypeTable[monDataType].monSize;
    std::size_t bufSize = monSize * partySize;
    bufSize = bufSize + (-bufSize & 3); // align to 4-byte boundary

    unsigned char *partyBuf = (unsigned char *)calloc(bufSize, 1);
    unsigned char *partyBufp = partyBuf;

    for (const auto &member : doc["party"].GetArray()) {
        TrainerMonBase base = {};
        base.dv = member["power"].GetUint();
        base.level = member["level"].GetUint();
        base.species = LookupConst(member["species"].GetString(), Species);
        base.species |= (member["form"].GetUint() << TRAINER_MON_FORM_SHIFT);
        base.cbSeal = member["ball_seal"].GetUint();

        subparser(member, base, partyBufp);
        partyBufp += monSize;
    }

    narc_pack_file(trpokeVFS, partyBuf, bufSize);
}

static std::string ParseMessages(const rapidjson::Document &doc, int trainerID, std::string stem, rapidjson::Value *outMessages, rapidjson::Document *messagesTextBank)
{
    rapidjson::Value trainerMessages(rapidjson::kArrayType);
    std::string ret = "";
    for (const auto &member : doc["messages"].GetArray()) {
        std::string type = member["type"].GetString();
        ret += (char)(trainerID & 0xFF);
        ret += (char)(trainerID >> 8);
        ret += (char)LookupConst(type, TrainerMessageType);
        ret += (char)0;

        rapidjson::Value message(rapidjson::kObjectType);
        std::string id = "NPCTrainerMessages_Text_" + stem + "_" + type;
        rapidjson::Value idValue(rapidjson::kStringType);
        idValue.SetString(id.c_str(), static_cast<rapidjson::SizeType>(id.length()), messagesTextBank->GetAllocator());
        message.AddMember("id", idValue, messagesTextBank->GetAllocator());

        CopyMessage(member, message, messagesTextBank->GetAllocator());

        trainerMessages.PushBack(message, messagesTextBank->GetAllocator());
    }
    *outMessages = trainerMessages;
    return ret;
}

static std::string ParseName(const rapidjson::Document &doc, int trainerID)
{
    std::string name = doc["name"].GetString();
    u8 trClass = LookupConst(doc["class"].GetString(), TrainerClass);

    static constexpr std::array<u8, 6> noTrNameClasses = {
        TRAINER_CLASS_RIVAL,
        TRAINER_CLASS_TOWER_TYCOON,
        TRAINER_CLASS_HALL_MATRON,
        TRAINER_CLASS_FACTORY_HEAD,
        TRAINER_CLASS_ARCADE_STAR,
        TRAINER_CLASS_CASTLE_VALET
    };
    static constexpr std::array<int, 5> noTrNameIDs = {
        861,
        862,
        863,
        864,
        865
    };

    if (std::find(std::begin(noTrNameClasses), std::end(noTrNameClasses), trClass) == std::end(noTrNameClasses) &&
        std::find(std::begin(noTrNameIDs), std::end(noTrNameIDs), trainerID) == std::end(noTrNameIDs)) {
        name = "{TRNAME}" + name;
    }
    return name;
}

int main(int argc, char **argv)
{
    if (argc == 1) {
        Usage(std::cout);
        return EXIT_SUCCESS;
    }

    fs::path outputRoot = argv[1];
    fs::path dataRoot = argv[2];

    std::vector<std::string> trainerRegistry = ReadRegistryEnvVar("TRAINERS");
    const int trainerCount = trainerRegistry.size();
    std::string *trMsgs = new std::string[trainerCount];
    short *trMsgOffsets = new short[trainerCount];
    int *order = new int[trainerCount];
    rapidjson::Value *messagesArr = new rapidjson::Value[trainerCount];

    vfs_pack_ctx *trdataVFS = narc_pack_start();
    vfs_pack_ctx *trpokeVFS = narc_pack_start();
    vfs_pack_ctx *trtblVFS = narc_pack_start();
    vfs_pack_ctx *trtblofsVFS = narc_pack_start();

    rapidjson::Document doc;
    rapidjson::Document messagesTextBank(rapidjson::kObjectType);
    rapidjson::Document namesTextBank(rapidjson::kObjectType);
    messagesTextBank.AddMember("key", 6120, messagesTextBank.GetAllocator());
    namesTextBank.AddMember("key", 55533, namesTextBank.GetAllocator());

    int trainerID = 0;
    int newTrainerIndex = 0;
    rapidjson::Value nameMessages(rapidjson::kArrayType);
    for (auto &trainerStem : trainerRegistry) {
        fs::path trainerDataPath = dataRoot / (trainerStem + ".json");
        std::string json = ReadWholeFile(trainerDataPath);
        rapidjson::ParseResult ok = doc.Parse(json.c_str(), json.length());
        if (!ok) {
            ReportJsonError(ok, json, trainerDataPath);
            std::exit(EXIT_FAILURE);
        }

        try {
            TrainerHeader trdata = ParseTrainerData(doc);
            narc_pack_file_copy(trdataVFS, reinterpret_cast<unsigned char *>(&trdata), sizeof(trdata));
            ParseAndPackParty(doc, static_cast<TrainerDataType>(trdata.monDataType), trdata.partySize, trpokeVFS);
        } catch (const std::exception &e) {
            std::cerr << e.what() << std::endl;
            std::exit(EXIT_FAILURE);
        }

        rapidjson::Value trainerMessages;
        std::string trMsg = ParseMessages(doc, trainerID, trainerStem, &trainerMessages, &messagesTextBank);

        std::string trName = ParseName(doc, trainerID);
        rapidjson::Value nameMessage(rapidjson::kObjectType);

        std::string id = "NPCTrainerNames_Text_" + trainerStem;
        rapidjson::Value idValue(rapidjson::kStringType);
        idValue.SetString(id.c_str(), static_cast<rapidjson::SizeType>(id.length()), namesTextBank.GetAllocator());
        nameMessage.AddMember("id", idValue, namesTextBank.GetAllocator());

        rapidjson::Value string(rapidjson::kStringType);
        string.SetString(trName.c_str(), static_cast<rapidjson::SizeType>(trName.length()), namesTextBank.GetAllocator());
        nameMessage.AddMember("en_US", string, namesTextBank.GetAllocator());

        nameMessages.PushBack(nameMessage, namesTextBank.GetAllocator());
        
        if (trMsg.length()) {
            if (trainerID < VANILLA_TRAINER_COUNT && trtblIndices[trainerID] != -1) {
                trMsgs[trtblIndices[trainerID]] = trMsg;
                order[trtblIndices[trainerID]] = trainerID;
                messagesArr[trtblIndices[trainerID]] = trainerMessages;
            } else {
                trMsgs[VANILLA_TRAINERS_WITH_MESSAGES + newTrainerIndex] = trMsg;
                order[VANILLA_TRAINERS_WITH_MESSAGES + newTrainerIndex] = trainerID;
                messagesArr[VANILLA_TRAINERS_WITH_MESSAGES + newTrainerIndex] = trainerMessages;
                newTrainerIndex++;
            }
        } else {
            trMsgOffsets[trainerID] = 0;
        }

        trainerID++;
    }
    
    namesTextBank.AddMember("messages", nameMessages, namesTextBank.GetAllocator());

    std::string str = "";
    int offset = 0;
    rapidjson::Value messages(rapidjson::kArrayType);
    for (int i = 0; i < trainerCount; i++) {
        str += trMsgs[i];
        int length = trMsgs[i].length();
        if (length) {
            trMsgOffsets[order[i]] = offset;
            offset += length;
            for (const auto &member : messagesArr[i].GetArray()) {
                rapidjson::Value tmp;
                tmp.CopyFrom(member, messagesTextBank.GetAllocator());
                messages.PushBack(tmp, messagesTextBank.GetAllocator());
            }
        }
    }
    messagesTextBank.AddMember("messages", messages, messagesTextBank.GetAllocator());

    char *chars = const_cast<char *>(str.c_str());
    narc_pack_file_copy(trtblVFS, reinterpret_cast<unsigned char *>(chars), offset);
    narc_pack_file_copy(trtblofsVFS, reinterpret_cast<unsigned char *>(trMsgOffsets), trainerCount * sizeof(short));

    PackNarc(trdataVFS, outputRoot / "trdata.narc");
    PackNarc(trpokeVFS, outputRoot / "trpoke.narc");
    PackNarc(trtblVFS, outputRoot / "trtbl.narc");
    PackNarc(trtblofsVFS, outputRoot / "trtblofs.narc");

    char writeBuffer[65536];

    FILE *fp = fopen((outputRoot / "npc_trainer_messages.json").string().c_str(), "w");
    rapidjson::FileWriteStream messagesStream(fp, writeBuffer, sizeof(writeBuffer));
    rapidjson::Writer<rapidjson::FileWriteStream> messagesWriter(messagesStream);
    messagesTextBank.Accept(messagesWriter);
    fclose(fp);

    fp = fopen((outputRoot / "npc_trainer_names.json").string().c_str(), "w");
    rapidjson::FileWriteStream namesStream(fp, writeBuffer, sizeof(writeBuffer));
    rapidjson::Writer<rapidjson::FileWriteStream> namesWriter(namesStream);
    namesTextBank.Accept(namesWriter);
    fclose(fp);

    delete[] trMsgs;
    delete[] trMsgOffsets;
    delete[] order;
    delete[] messagesArr;
    return EXIT_SUCCESS;
}
