/*
 * datagen-trainer
 *
 * Usage: datagen-species <OUT_DIR> <ROOT_DIR>
 *
 * This program is responsible for generating data archives from trainer data
 * files (res/trainers/data/*.json). The file-names to be polled for data are
 * drawn from an environment var TRAINERS, which should be a semicolon-delimited
 * list of file-stems.
 *
 * The following files are generated by this program:
 *   - trdata.narc
 *   - trpoke.narc
 */
#include <cstdlib>
#include <cstring>
#include <exception>
#include <functional>

#include "datagen.h"

#define POKEPLATINUM_GENERATED_LOOKUP
#define POKEPLATINUM_GENERATED_LOOKUP_IMPL

// C++ does not like the math expressions used in this enum,
// so use the preprocessor version instead.
#include "generated/ai_flags.h"

#define POKEPLATINUM_GENERATED_ENUM

#include "constants/battle.h"
#include "generated/items.h"
#include "generated/moves.h"
#include "generated/species.h"
#include "generated/trainer_classes.h"

#include "struct_defs/trainer_data.h"

static void PackImmediately(const rapidjson::Value &member, TrainerMonBase &base, unsigned char *bufp);
static void ParseMovesAndPack(const rapidjson::Value &member, TrainerMonBase &base, unsigned char *bufp);
static void ParseItemAndPack(const rapidjson::Value &member, TrainerMonBase &base, unsigned char *bufp);
static void ParseMovesAndItemAndPack(const rapidjson::Value &member, TrainerMonBase &base, unsigned char *bufp);

typedef std::function<void(const rapidjson::Value &member, TrainerMonBase &base, unsigned char *bufp)> TrainerMonSubparser;

struct TrainerDataTypeTable {
    TrainerMonSubparser subparser;
    std::size_t monSize;
};

static TrainerDataTypeTable sTrainerDataTypeTable[] = {
    { PackImmediately, sizeof(TrainerMonBase) },
    { ParseMovesAndPack, sizeof(TrainerMonWithMoves) },
    { ParseItemAndPack, sizeof(TrainerMonWithItem) },
    { ParseMovesAndItemAndPack, sizeof(TrainerMonWithMovesAndItem) },
};

static void Usage(std::ostream &ostr)
{
    ostr << "Usage: datagen-species OUT_DIR ROOT_DIR" << std::endl;
    ostr << std::endl;
    ostr << "Generates data archives from trainer data files (res/trainers/data/*.json)" << std::endl;
    ostr << "Trainer data files to be polled for packing are drawn from the environment var\n"
         << "TRAINERS, which must be a semicolon-delimited list of file-stems to be polled\n"
         << "at execution." << std::endl;
}

static inline bool AnyMemberHasValue(const rapidjson::Value &party, const char *key)
{
    for (const auto &member : party.GetArray()) {
        if (!member[key].IsNull()) {
            return true;
        }
    }

    return false;
}

static TrainerHeader ParseTrainerData(const rapidjson::Document &doc)
{
    TrainerHeader trdata = {};

    trdata.trainerType = LookupConst(doc["class"].GetString(), TrainerClass);
    trdata.battleType = doc["double_battle"].GetBool() ? BATTLE_TYPE_DOUBLES : 0;

    int i = 0;
    for (const auto &itemVal : doc["items"].GetArray()) {
        trdata.items[i++] = LookupConst(itemVal.GetString(), Item);
    }

    for (const auto &aiFlagsVal : doc["ai_flags"].GetArray()) {
        trdata.aiMask |= LookupConst(aiFlagsVal.GetString(), AIFlag);
    }

    const rapidjson::Value &party = doc["party"];
    trdata.partySize = party.GetArray().Size();

    bool partyItems = AnyMemberHasValue(party, "item");
    bool partyMoves = AnyMemberHasValue(party, "moves");
    if (partyItems) {
        if (partyMoves) {
            trdata.monDataType = TRDATATYPE_WITH_MOVES_AND_ITEM;
        } else {
            trdata.monDataType = TRDATATYPE_WITH_ITEM;
        }
    } else if (partyMoves) {
        trdata.monDataType = TRDATATYPE_WITH_MOVES;
    } else {
        trdata.monDataType = TRDATATYPE_BASE;
    }

    return trdata;
}

static void PackImmediately(const rapidjson::Value &member, TrainerMonBase &base, unsigned char *bufp)
{
    memcpy(bufp, &base, sizeof(base));
}

static void ParseMovesAndPack(const rapidjson::Value &member, TrainerMonBase &base, unsigned char *bufp)
{
    TrainerMonWithMoves withMoves = {};
    withMoves.dv = base.dv;
    withMoves.level = base.level;
    withMoves.species = base.species;
    withMoves.cbSeal = base.cbSeal;

    int i = 0;
    for (const auto &move : member["moves"].GetArray()) {
        withMoves.moves[i++] = LookupConst(move.GetString(), Move);
    }

    memcpy(bufp, &withMoves, sizeof(withMoves));
}

static void ParseItemAndPack(const rapidjson::Value &member, TrainerMonBase &base, unsigned char *bufp)
{
    TrainerMonWithItem withItem = {};
    withItem.dv = base.dv;
    withItem.level = base.level;
    withItem.species = base.species;
    withItem.cbSeal = base.cbSeal;

    withItem.item = LookupConst(member["item"].GetString(), Item);

    memcpy(bufp, &withItem, sizeof(withItem));
}

static void ParseMovesAndItemAndPack(const rapidjson::Value &member, TrainerMonBase &base, unsigned char *bufp)
{
    TrainerMonWithMovesAndItem withMovesAndItem = {};
    withMovesAndItem.dv = base.dv;
    withMovesAndItem.level = base.level;
    withMovesAndItem.species = base.species;
    withMovesAndItem.cbSeal = base.cbSeal;

    int i = 0;
    for (const auto &move : member["moves"].GetArray()) {
        withMovesAndItem.moves[i++] = LookupConst(move.GetString(), Move);
    }

    withMovesAndItem.item = LookupConst(member["item"].GetString(), Item);

    memcpy(bufp, &withMovesAndItem, sizeof(withMovesAndItem));
}

static void ParseAndPackParty(const rapidjson::Document &doc, TrainerDataType monDataType, std::size_t partySize, vfs_pack_ctx *trpokeVFS)
{
    if (partySize == 0) {
        unsigned char *buf = (unsigned char *)calloc(8, 1);
        narc_pack_file(trpokeVFS, buf, 8);
        return;
    }

    TrainerMonSubparser subparser = sTrainerDataTypeTable[monDataType].subparser;
    std::size_t monSize = sTrainerDataTypeTable[monDataType].monSize;
    std::size_t bufSize = monSize * partySize;
    bufSize = bufSize + (-bufSize & 3); // align to 4-byte boundary

    unsigned char *partyBuf = (unsigned char *)calloc(bufSize, 1);
    unsigned char *partyBufp = partyBuf;

    for (const auto &member : doc["party"].GetArray()) {
        TrainerMonBase base = {};
        base.dv = member["power"].GetUint();
        base.level = member["level"].GetUint();
        base.species = LookupConst(member["species"].GetString(), Species);
        base.species |= (member["form"].GetUint() << TRAINER_MON_FORM_SHIFT);
        base.cbSeal = member["ball_seal"].GetUint();

        subparser(member, base, partyBufp);
        partyBufp += monSize;
    }

    narc_pack_file(trpokeVFS, partyBuf, bufSize);
}

int main(int argc, char **argv)
{
    if (argc == 1) {
        Usage(std::cout);
        return EXIT_SUCCESS;
    }

    fs::path outputRoot = argv[1];
    fs::path dataRoot = argv[2];

    std::vector<std::string> trainerRegistry = ReadRegistryEnvVar("TRAINERS");

    vfs_pack_ctx *trdataVFS = narc_pack_start();
    vfs_pack_ctx *trpokeVFS = narc_pack_start();

    rapidjson::Document doc;
    for (auto &trainerStem : trainerRegistry) {
        fs::path trainerDataPath = dataRoot / (trainerStem + ".json");
        std::string json = ReadWholeFile(trainerDataPath);
        rapidjson::ParseResult ok = doc.Parse(json.c_str(), json.length());
        if (!ok) {
            ReportJsonError(ok, json, trainerDataPath);
            std::exit(EXIT_FAILURE);
        }

        try {
            TrainerHeader trdata = ParseTrainerData(doc);
            narc_pack_file_copy(trdataVFS, reinterpret_cast<unsigned char *>(&trdata), sizeof(trdata));
            ParseAndPackParty(doc, static_cast<TrainerDataType>(trdata.monDataType), trdata.partySize, trpokeVFS);
        } catch (const std::exception &e) {
            std::cerr << e.what() << std::endl;
            std::exit(EXIT_FAILURE);
        }
    }

    PackNarc(trdataVFS, outputRoot / "trdata.narc");
    PackNarc(trpokeVFS, outputRoot / "trpoke.narc");
    return EXIT_SUCCESS;
}
